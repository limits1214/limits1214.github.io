- 32비트 컴퓨터, 64비트 컴퓨터의 32, 64는 뭐지?
- 스택, 힙이란 뭐지?
- c함수중에 _s 붙은 애들은 뭐지?
- 역참조는 포인터만 할수 있나?
- 
```
char testChar[4] = "sdf";

cout << "1:" << &testChar[0] << endl;
cout << "2:" << &testChar << endl;

이거 1:, 2: 2개가 같은 주소이길 기대했는데
1: 은 sdf 문자열을 출력하고, 2:는 주소값을 찍었다
왜이런 차이가 발생했을까?

그이유는 << 의 오버로딩에 관련되어있다.
&testChar[0] 의 testChar[0] 은 char 타입이고 이거의 주소니 char* 가 된다.
이경우 << 의 char* 오버로딩으로 호출된다. 해당 오버로딩에서는 char*의경우 널문자열이 나올때까지 출력한다라고 구현이 되어 있기때문에 주소값이 아닌 문자열 전체가 나온것이다.
&testChar 의경우 testChar 배열의 주소이다. c 에서 배열의 주소는 시작 주소와 같다
명확하게 char* 가아닌 char*[4] 배열전체를 가르키므로 char*를 타지 않는다.
```

errorno가 뭐야
errorno의 경우 0 리턴이 정상이다. 하지만 if문에서 0은 false로 취급되므로 !를 주거나 == 0 조건을 줘야한다.

메모리 블록이란?

memmove는
그저 앞에서 복사하는 memcpy와 다르게
원본이 덮이지 않게 왼쪽 또는 오른쪽으로부터 복사를 진행한다.
겹치면 어쩔수 없이 덮이지만...
만약 dst가 src보다 뒤라면 뒤에서부터 앞으로 복사를진행하고
dst가 src보다 앞이라면 앞에서부터 뒤로 복사를 진행한다.

이중포인터 삼중포인터는 언제 써야하는거지?



sbcs, wbcs, mbcs? 시스템 프로그래밍에서 문자열 체계에대한 내용


strcpy 하고 memcpy차이가 뭐지?

c함수에서 사이즈 넘기는데 src size? dst size?
```
안전한건 min(src size, dst size)로해야함
src보다 크게 복사하면 원본 범위를 넘어 읽어 UB 또는 크래시가 난다
dst보다 크게 복사하면 목적지 범위를 넘어 쓰는 버퍼 오버플러우 및 보안 취약점이 발생할수 있다

memcpy같은거는 dst size기준으로 해주기
```

왜 예시에서 차 배열에 32 를 보통 두지?
```
별다른 이유는 아니고 적당한 값을 준것일뿐
널문자 포함해서 31자를입력가능하고 차가 1바이트니까 32 바이트 차지한다는의미

32 처럼 2의거듭제곱을 준 이유는 메모리 패딩과 관련 있기때문
cpu는 데이터를 읽을때 정렬된 주소에서 읽는게 빠르기때문
컴파일러는 정렬을 맞추기위해 뒤에 패딩을 추가하는데 그러지 않기위해서
2의 거듭제곱수로 선언하고 패딩 낭비를 줄인다
```


정렬이란?(메모리 레이아웃이란)
```
cpu는 메모리를 읽고 쓰는 최소 단위에 맞춰 접근하는게 가장 빠릅니다
32비트 cpu는 4바이트 단위
64비트 cpu는 8바이트 단위
그래서 컴파일러는 구조체 멤버들을 배치할때
각 타입이 자신의 크기와 잘 맞는 배수에 놓이도록 정렬합니다
정렬이 맞지않으면 cpu가 여러번 접근해야해서 느려지거나
어떤 아키텍쳐에서는 버스 에러가 날수 있다.

규칙
1. 각 멤버는 자신의 크기의 배수 주소에 놓임
int(4바이트)는 주소가 4의 배수 여야함
double은 주소가 8의 배수 여야함

2. 구조체 전체 크기는 가장 큰 멤버의 align 크기 배수가 됨
즉, 마지막에도 패딩이 들어갈 수 있음

각 멤버바다 자기 정렬 에 맞춰 배치하고
구조체 전체는 가장 큰 정렬단위 배수로 끝을 맞춘다

정렬 공식
#define ALIGN_UP(N, A) (((N) + (A) - 1) / (A) * (A))
```

왜 cpu는 최소단위에 맞춰 접근하는게 빠른거야?
```
하드웨어 자체가 최소단위로 읽어오게 설계되어 있음
버스나 레지스터가 근데 정렬은 안맞추면
같은 데이터도 한번에 읽는게 아니라 파편화된데이터가 되어서 여러번 읽어버리는 비효율이 발생할수있다
그래서 최소단위에 맞춰서 접근하는게 빠르다
```


statement? expression?

초기화하지 않은 포인터는 UB이다

클래스 상호참조 전방선언 할때
헤더파일에 전방선언하고 포인터로만들고 cpp파일에서 원본 헤더파일 인클루드 해준다.
그래서 최근에는 헤더에는 전방산언만하고 cpp에서 헤더 인클루드하는 형식으로 관행이 변경 되어 간다.

생성자에서 상호 참조중인 포인터를 new할때는 순환참조가 나버려서 생성이안될수있다
그래서 생성자에서는 널포인터만주고new할때는 바깥에서 해주는거를 추천한다.
생성자에서는 포인터 널포인터만 주자
생성자 단계에서 쓸데없이 주소 주지 말자 이게 문제가 많이 된다.

nullptr 말고 NULL이나 다른 널 표현에들은 뭐지? nullptr가표준이 된건가?

pod란?

아무것도 없는 클래스의 사이즈가 1이네

클래스에 스태틱이 있는경우 클래스에 sizeof하면 클래스변수들은 제외하고 사이즈가 나온다

클래스를 정의하면
기본적으로 4개
생성자, 소멸자, 복사생성자, 복사대입연산자 생성된다 기본으로

복사 생성자가 불리면
포인터멤버가 아니면 멤버별복사가 이루어지고,
포인터의경우 얕은 복사가 이루어진다.

char [] 는 포인터인가? 배열인가?

char*가 동적할당인지 아닌지 알수 없음


char* asdf = "asdf" 는안되고
const char* asdf = "asdf"는 되는이유?
이유는 "asdf"자체가 코드에 작성된 리터럴이고 이 리터럴은 읽기전용인 rodata영역에 들어가는데
이거를 char*로 선언하면 변경가능해져버리므로 막은거다.

rhs? lhs?
rhs: right hand side
lhs: left hand side
연산자 기준으로 왼쪽에 오는지 오른쪽에 오는지 표기
int x = 10;
rhs 는 10 lhs는 x 이다

프로그램 읽을때
오른쪽 에서 왼쪽으로 보통 읽는데
이는 
cpp operator precedence에 의한것이다.
보면 연산자에대한 우선순위 및 왼쪽 오른쪽 어디서 읽어야하는지 나와있다.