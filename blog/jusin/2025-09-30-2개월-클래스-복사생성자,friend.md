1. 클래스 복사 생성자

클래스가 만들어지면 디폴트로
생성자, 소멸자, 복사 생성자, 복사 대입 연사자가 만들어진다.

디폴트로 만들어진 복사 생성자는
비포인터 멤버에대해서는 멤버간복사가 이루어지고, 포인터에대해서는 얕은 복사가 이루어진다.
그렇기때문에 복사 생성자를 통해 얕은 복사된 멤버 포인터들이 소멸자에의해 두번이상 해제되는 문제가 생길수 있다.

```cpp
class Foo
{
public:
    Foo()
    {
        cout << "기본 생성자" << endl;
    };
    // 복사 생성자, const 와 레퍼런스를 꼭 붙여주자
    Foo(const Foo& foo)
    {
        cout << "복사 생성자" << endl;
    }
    int GetIA() const { return m_iA; }
private:
    int m_iA{};
};

```

복사 생성자가 발생할때는 
1. 기존객체로 새로운 객체를 만들어낼때
```cpp
// 기존객체 복사할때
Foo f;
Foo f2(f); 

```
2. 콜바이밸류로 함수의 매개변수로써 사용될때
```cpp
// void PrintFoo(Foo f); 함수의 파라미터로 복사 생성자가 수행됨
PrintFoo(f);
```
3. 함수의 반환값으로 객체가 반환될때 사용되는 복사 동작
```cpp
// 하지만 현대 컴파일러에서는 반환값 최적화로 인해 값 반환시 복사 생성자가 불리지는 않는다.
Foo RetFoo()
{
    Foo f;
    return f;
}
Foo ret = RetFoo();
```


복사생성자에서 포인터 멤버 깊은 복사 예시
```cpp
class Str
{
public:
    Str(const char* chars)
    {
        int size = strlen(chars) + 1;
        m_szStr = new char[size];
        strcpy_s(m_szStr, size, chars);
    }
    // 복사 생성자
    Str(const Str& s)
    {
        int size = strlen(s.m_szStr) + 1;
        // 새로 주소를 받는다.
        m_szStr = new char[size];
        strcpy_s(m_szStr, size, s.m_szStr);
    }
    ~Str()
    {
        if (nullptr != m_szStr)
        {
            delete m_szStr;
            m_szStr = nullptr;
        }
    }
    char* GetStr() const { return this->m_szStr; }
private:
    char* m_szStr;
};

int main()
{
    Str s("asdf");
    cout << "s: " << s.GetStr() << ", " << (void*)s.GetStr() << endl;
    Str s2(s);
    cout << "s2: " << s2.GetStr() << ", " << (void*)s2.GetStr() << endl;

    // s, s2의 GetStr 의 주소값이 서로 다른것을 보아 깊은 복사가 이루어 졌다.

    // 여기서 만약 복사 생성자를 만들어 주지 않고 디폴트 복사 생성자를 사용하면
    // 깊은 복사가 아닌 얕은 복사가 만들어지고
    // s, s2의 GetStr이 같은 주소를 바라보고, 2개의 객체의 소멸자가 동일한 주소를
    // 해제할때 에러가발생하므로
    // 주의해야한다.
}
```



// -----
friend 
friend는 어떠한 함수에서 private인 클래스의 멤버에 접근가능하도록 해주는 지시어 이다.

```cpp
#include <iostream>
using namespace std;

void Other();


class Foo
{
public:
	void Do();
};

class Bar
{
public:
    // Foo 클래스 전체가 Bar 클래스의 private멤버에 접근가능하도록 허용
	friend class Foo;
    
    // Foo 클래스의 Do 메소드가 Bar 클래스의 private멤버에 접근 가능하도록 허용
	friend void Foo::Do();

    // Other함수가 Bar 클래스의 private멤버에 접근 가능하도록 허용
	friend void Other();
private:
	int m_i;
};

void Foo::Do()
{
	Bar b;
	cout << b.m_i << endl;
}

void Other()
{
	Bar b;
	cout << b.m_i << endl;
}
```